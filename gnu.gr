// gnu.gr            see license.txt for copyright and terms of use
// extension to cc.gr for GNU C/C++ language extensions

// NOTE: Though the name of this module is "gnu.gr", in fact we also
// put our C99 support here.  For the moment, it isn't worth it to
// split out C99 from GNU, because our usage model is that either you
// want to parse ANSI C++, or you want to parse whatever gcc/g++
// accepts.  The "gnu" extensions (try to) provide the latter.  (Also,
// there are a few extensions like "long long" that are provided by
// both, so the split wouldn't be 100% clean.)
//
// 9/27/04: The current concept is that gnu.gr contains the syntactic
// extensions included in the modern, extended C++ language,
// especially as used on linux.  It does *not* include old K&R syntax,
// which will be put in kandr.gr.
//
// Specifically, the extensions found in this file are:
//   - gcc statement expression: "({ ... })"
//   - gcc compound literals: "(struct Foo){ ... }"
//   - gcc misc: __FUNCTION__, __alignof__, etc.
//   - gcc typeof
//   - gcc C++ min and max operators ">?" and "<?"
//   - gcc asm with register constraints, etc.
//   - gcc asm labels: "int foo asm("myfoo") = 2"
//   - C99 designated initializers: "... = { .x=..., .y=... }"
//     including gcc range extension: "[ 1 ... 3 ] = ..."
//   - C99 restrict keyword
//   - C99 qualifiers in array brackets: "[const ...]"
//   - gcc __attribute__
//   - gcc bug: typedef names + type modifiers: "u32 long"
//   - gcc computed gotos
//   - gcc/C99 complex/imaginary


verbatim {
  #include "ubermods-attrspec.h"       // UberModifiersAndASL
}

// expected statistics
option shift_reduce_conflicts 76;
option reduce_reduce_conflicts 94;


terminals {
  precedence {
    // see note at end regarding implementation of __attribute__
    prec  190 "__attribute__" "restrict";

    // the experimentation I did in in/gnu/g0019.cc suggests that
    // these operators have the same prec/assoc as "<" and ">"
    //left   80 "<?" ">?";
  }
}


// ----------- gcc statement expression -----------
// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Statement-Exprs.html
nonterm(Expression*) PrimaryExpression {
  -> "(" cs:CompoundStatement ")"
       { return new E_statement(cs); }
}


// ----------- gcc compound literals -----------
// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Compound-Literals.html
// (notation for literal struct values)
// e.g.:
//   struct Foo { int x; int y; } myfoo;
//   myfoo = (struct Foo) { 4, 5 };        <-- here
// which would assign x=4 and y=5 in 'myfoo'
nonterm(Expression*) PrimaryExpression {
  -> "(" t:TypeId ")" i:CompoundInitializer
       { return new E_compoundLit(t, i); }
}


// ----------- gcc misc -----------
// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Function-Names.html
nonterm(StringRef) PreprocString {
  // slightly subtle: ordinary strings are yielded *with quotes*,
  // whereas these special guys are not quoted; also note that
  // yielding of these token codes depends on lang.gccFuncBehavior
  -> TOK___FUNCTION__                       { return str("__FUNCTION__"); }
  -> TOK___PRETTY_FUNCTION__                { return str("__PRETTY_FUNCTION__"); }
}

nonterm(Expression*) UnaryExpression {
  // GNU extension; dsw: Since the argument is an expression, I know
  // of no way to handle this other than putting it into the grammar
  // directly.
  -> "__builtin_constant_p" pe:ParenthesizedExpression
       { return new E___builtin_constant_p(loc, pe); }

  // http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Alignment.html
  -> "__alignof__" "(" t:TypeId ")"
       { return new E_alignofType(t); }
  -> "__alignof__" "(" e:Expression ")"
       { return new E_alignofExpr(e); }

  // https://gcc.gnu.org/onlinedocs/gcc/Offsetof.html
  //
  // TODO: 'fieldName' can actually be a sequence of fields and array
  // index expressions.
  -> "__builtin_offsetof" "(" t:TypeId "," n:NameAfterDot ")"
       { return new E_offsetof(t, n); }

  -> "__offsetof__" "(" e:Expression ")"
       { return new E_grouping(e); }

  // sm: __builtin_expect is for static branch prediction, but none of
  // the analyses I forsee for this parser care about such things, so
  // I will simply pretend I never even saw it (though, this is a
  // small problem for source to source ...); the alternative is to make
  // a new AST node for it, or else squeeze it into E_funCall, neither of
  // which is very attractive
  //
  // A third possibility is a new "semantically transparent but
  // annotated in some way" AST node, of which __builtin_expect could
  // be one kind.  I'm not sure what other kinds there would be,
  // though.
  -> "__builtin_expect" "(" e:Expression "," /*prediction*/Expression ")"
       { return new E_grouping(e); }

  // varargs; dsw: I think that we should make all of these their own
  // AST node, I just don't want to deal with the parsing ambiguity
  // with E_funCall right now
//   -> "__builtin_va_start" "(" e:Expression "," e2:Expression ")"
//        { return new E___builtin_va_start(loc, e, e2); }
//   -> "__builtin_va_copy" "(" e:Expression "," e2:Expression ")"
//        { return new E___builtin_va_copy(loc, e, e2); }
  -> "__builtin_va_arg" "(" e:Expression "," t:TypeId ")"
       { return new E___builtin_va_arg(loc, e, t); }
//   -> "__builtin_va_end" "(" e:Expression ")"
//        { return new E___builtin_va_end(loc, e); }
}

// dsw: had to break this out for location recording reasons
nonterm(Expression*) ParenthesizedExpression {
  -> "(" e:Expression ")"
       { return new E_grouping(e); }
}


// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Conditionals.html
nonterm(Expression*) ConditionalExpression {
  -> cond:BinaryExpression "?" /*th:Expression*/ ":" el:AssignmentExpression
       { return new E_gnuCond(cond, el); }
}


// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Nested-Functions.html
nonterm(Statement*) Statement {
  -> f:FunctionDefinition
       { return new S_function(loc, f); }
  // quarl 2006-06-15
  //    nested K&R functions; unimplemented for now but I guess we just need
  //    to do the same as above?  see in/gnu/k0010.c
  //
  // 2022-05-20: smcpeak: Disabling this in part because this should be
  // in kandr.gr.
  //-> k:KandRFunctionDefinition
  //     { xunimp(stringc << loc << "nested K&R function definition"
  //              " (d00aa531-ca12-4d72-9caf-ca9db9941179)"); }
}


// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Template-Instantiation.html
nonterm(TopForm*) ExplicitInstantiation {
  // here's one for things like (in/gnu/g0002.cc)
  //   extern template class allocator<char>;
  -> "extern" "template" d:BlockDeclaration
       { return new TF_explicitInst(loc, DF_EXTERN, d); }
}


// http://gcc.gnu.org/onlinedocs/gcc-3.4.1/gcc/Case-Ranges.html
nonterm(Statement*) Statement {
  -> "case" e:ConstantExpression "..." e2:ConstantExpression ":" s:Statement
       { return new S_rangeCase(loc, e, e2, s); }
}


// 2022-05-25: There previously was support here for a label at the end
// of a compound statement, like: "{ label: }", which was accepted by
// the nonterminal LabeledEmptyStatementList.  That is invalid C and
// C++.  GCC 2.x accepts it, but GCC 3 and later do not.  It was
// somewhat in my way while adding support for attributes on labels, so
// I removed it entirely.


// ----------- gcc typeof -----------
// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Typeof.html

verbatim {
  // make a TS_typeof, and supply CV flags
  inline static TS_typeof *new_TS_typeof(SourceLoc loc, CVFlags cv, ASTTypeof *atype)
  {
    TS_typeof *ret = new TS_typeof(loc, atype);
    ret->cv = cv;
    return ret;
  }
}


nonterm(Declaration*) DeclSpecifier {
  // TS_typeof: triggered by TypeTypeSpecifier
  -> te:TypeofTypeSpecifier m2:UberModifierSeqOpt
       { return new Declaration(uberDeclFlags(m2),
           new_TS_typeof(loc, uberCVFlags(m2), te), NULL); }

  -> m1:UberModifierSeq te:TypeofTypeSpecifier m2:UberModifierSeqOpt
       { UberModifiers m = uberCombine(loc, m1, m2);
         return new Declaration(uberDeclFlags(m),
           new_TS_typeof(loc, uberCVFlags(m), te), NULL); }
}


nonterm(TypeSpecifier*) TypeSpecifier {
  // TS_typeof
  -> te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt
       { return new_TS_typeof(loc, uberCVFlags(cv2), te); }

  -> cv1:UberCVQualifierSeq te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt
       { UberModifiers cv = uberCombine(loc, cv1, cv2);
         return new_TS_typeof(loc, uberCVFlags(cv), te); }
}


// this production isolates the ambiguity to within itself, rather
// than letting it pollute upwards into TypeSpecifier
nonterm(ASTTypeof*) TypeofTypeSpecifier {
  // ambiguous:
  //   typeof(x)
  // could either be type of an expression 'x', or
  // type (of a type) called 'x'
  fun merge(L,R) { L->addAmbiguity(R); return L; }

  -> e:TypeofExpr       { return new TS_typeof_expr(e); }
  -> t:TypeofType       { return new TS_typeof_type(t); }
}


// gnu extension
nonterm(FullExpression*) TypeofExpr {
  -> "__typeof__" "(" e:Expression ")"
       { return new FullExpression(e); }
}

// gnu extension
nonterm(ASTTypeId*) TypeofType {
  -> "__typeof__" "(" t:TypeId ")"
       { return t; }
}


// ----------- gcc C++ min and max operators -----------
// http://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Min-and-Max.html
nonterm(Expression*) BinExp_mid {
  -> left:BinExp_mid "<?" right:BinExp_high
       { return new E_binary(left, BIN_MINIMUM, right); }
  -> left:BinExp_mid ">?" right:BinExp_high
       { return new E_binary(left, BIN_MAXIMUM, right); }
}

// it turns out gcc lets users overload them too (in/gnu/k0004.cc)
nonterm(OperatorName*) Operator {
  -> "<?"    { return new ON_operator(OP_MINIMUM); }
  -> ">?"    { return new ON_operator(OP_MAXIMUM); }
}


// ----------- gcc asm -----------
nonterm(CVFlags) VolatileOpt {
  -> empty         { return CV_NONE; }
  -> "volatile"    { return CV_VOLATILE; }
}

nonterm(AsmDefinition*) AsmDefinition {
  -> "asm" q:VolatileOpt "(" t:StringLiteral
                             ":" output:GNUAsmOperandListOpt
                             ":" input:GNUAsmOperandListOpt
                             clobbers:GNUAsmClobberListOpt ")" ";"
       { return new AD_gnu(q, t, output, input, clobbers); }

  // Variant with missing inputs and clobbers.
  -> "asm" q:VolatileOpt "(" t:StringLiteral
                             ":" output:GNUAsmOperandListOpt ")" ";"
       { return new AD_gnu(q, t, output, new ASTList<GNUAsmOperand>(),
                           new ASTList<E_stringLit>()); }

  // Variant with missing inputs, using "::" to get to clobbers.  This
  // is special because "::" is treated as a single token.
  -> "asm" q:VolatileOpt "(" t:StringLiteral
                             ":" output:GNUAsmOperandListOpt
                             "::" clobbers:GNUAsmClobberList ")" ";"
       { return new AD_gnu(q, t, output, new ASTList<GNUAsmOperand>(),
                           clobbers); }

  // Variant with "::" to skip the outputs.
  -> "asm" q:VolatileOpt "(" t:StringLiteral
                             "::" input:GNUAsmOperandListOpt
                             clobbers:GNUAsmClobberListOpt ")" ";"
       { return new AD_gnu(q, t, new ASTList<GNUAsmOperand>(), input,
                           clobbers); }

  // Variant with all operands missing.  The GCC manual implies this is
  // illegal, but it appears in the wild and GCC accepts it.  (Without
  // "volatile", this would be the standard C++ form, which is parsed by
  // the rule in cc.gr.)
  -> "asm" "volatile" "(" t:StringLiteral ")" ";"
       { return new AD_gnu(CV_VOLATILE, t, new ASTList<GNUAsmOperand>(),
                           new ASTList<GNUAsmOperand>(),
                           new ASTList<E_stringLit>()); }

  // TODO: There is a form with "asm" followed by "goto", which has a
  // total of four lists after colons.
}


nonterm(ASTList<GNUAsmOperand>*) GNUAsmOperandListOpt {
  -> empty
       { return new ASTList<GNUAsmOperand>(); }
  -> list:GNUAsmOperandList
       { return list; }
}

nonterm(ASTList<GNUAsmOperand>*) GNUAsmOperandList {
  -> element:GNUAsmOperand
       { return new ASTList<GNUAsmOperand>(element); }
  -> list:GNUAsmOperandList "," element:GNUAsmOperand
       { list->append(element); return list; }
}

nonterm(GNUAsmOperand*) GNUAsmOperand {
  -> "[" name:Identifier "]" c:StringLiteral "(" e:Expression ")"
       { return new GNUAsmOperand(name, c, e); }
  -> c:StringLiteral "(" e:Expression ")"
       { return new GNUAsmOperand(NULL /*asmSymbolicName*/, c, e); }
}


nonterm(ASTList<E_stringLit>*) GNUAsmClobberListOpt {
  -> empty
       { return new ASTList<E_stringLit>(); }
  -> ":"
       { return new ASTList<E_stringLit>(); }
  -> ":" list:GNUAsmClobberList
       { return list; }
}

nonterm(ASTList<E_stringLit>*) GNUAsmClobberList {
  -> s:StringLiteral
       { return new ASTList<E_stringLit>(s); }
  -> list:GNUAsmClobberList "," s:StringLiteral
       { list->append(s); return list; }
}


// ----------- gcc asm labels -----------
// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Asm-Labels.html
nonterm(IDeclarator*) Declarator {
  // Asm Labels after declarators; see in/gnu/asm01.c
  -> d:DirectDeclarator "asm" "(" StringLiteral ")"
       { return d; }

  // asm label + attributes ...
  -> d:DirectDeclarator "asm" "(" StringLiteral ")" asl:AttributeSpecifierList
       { d->appendASL(asl); return d; }
}


// ----------- C99 designated initializers -----------
// Designated Initializers
nonterm(Initializer*) InitializerClause {
  // obsolescent form
  // http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Designated-Inits.html
  -> d:Identifier ":" init:SimpleInitializerClause
    { return new IN_designated(loc, FakeList<Designator>::makeList(new FieldDesignator(loc, d)),
                               init); }
  // C99 official form; C99 standard section 6.7.8
  -> dl:DesignatorList "=" init:SimpleInitializerClause
    { return new IN_designated(loc, dl, init); }
  // dsw: another form I run into
  -> dl:DesignatorList init:SimpleInitializerClause
    { return new IN_designated(loc, dl, init); }
}

nonterm(FakeList<Designator>*) DesignatorList {
  -> d:Designator
    { return FakeList<Designator>::makeList(d); }
  -> d:Designator dl:DesignatorList
    { d->setNext(fl_first(dl));
    return FakeList<Designator>::makeList(d); }
}

nonterm(Designator*) Designator {
  -> "." id:Identifier
    { return new FieldDesignator(loc, id); }
  -> "[" idx_expr:ConstantExpression "]"
    { return new SubscriptDesignator(loc, idx_expr, NULL); }
  // range designator "[ 1 ... 3 ] =".  This is a gcc-ism:
  // http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Designated-Inits.html
  -> "[" idx_expr:ConstantExpression "..." idx_expr2:ConstantExpression "]"
    { return new SubscriptDesignator(loc, idx_expr, idx_expr2); }
}


// ----------- C99 restrict keyword -----------
nonterm(enum CVFlags) CVQualifier {
  -> "restrict"              { return CV_RESTRICT; }
}

nonterm(UberModifiers) UberModifier {
  -> "restrict"              { return UM_RESTRICT; }
}

nonterm(UberModifiers) UberCVQualifier {
  -> "restrict"              { return UM_RESTRICT; }
}


// ----------- C99 qualifiers in array brackets -----------
nonterm(IDeclarator*) DirectDeclarator {
  // array with qualifier in the brackets; see the version for
  // DirectAbstractDeclarator for comments
  -> d:DirectDeclarator "[" q:CVQualifierSeq "]"
    {
      // FIX: CVQualifierSeq goes on the array
      return new D_array(loc, d, NULL /*size*/);
    }
}

nonterm(IDeclarator*) DirectAbstractDeclarator {
  // array with qualifier in the brackets
  -> d:DirectAbstractDeclaratorOpt "[" q:CVQualifierSeq "]"
    {
      // FIX: Ben says the CVQualifierSeq goes on the array itself,
      // just as if the array were a pointer and it was on the pointer
      return new D_array(loc, d, NULL /*size*/);
    }
}


// 2022-05-19: I removed support for the gcc2 bug: "u32 long", which
// used the nonterminal "BuggyGccTypeModifier".


// ------------ gcc computed goto ----------
// http://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Labels-as-Values.html
nonterm(Expression*) UnaryExpression {
  -> "&&" n:Identifier
       { return new E_addrOfLabel(n); }
}

nonterm(Statement*) Statement {
  -> "goto" "*" e:Expression ";"
       { return new S_computedGoto(loc, e); }
}


// ----------- gcc/C99 complex/imaginary ----------
// http://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Complex.html
// C99 6.2.5p11, 6.7.2, Annex G
nonterm(UberModifiers) UberTypeKeyword {
  -> "_Complex"      { return UM_COMPLEX; }
  -> "_Imaginary"    { return UM_IMAGINARY; }
}

// The gcc manual says the syntax is "__real__" Expression, but I'll
// take a conservative approach for now and only allow primary
// expressions, thus avoiding the need to specify precedence of these
// keywords.
//
// I've chosen to create E_fieldAcc AST nodes because they are similar,
// in that these are component accesses.
nonterm(Expression*) PrimaryExpression {
  -> "__real__" e:PrimaryExpression
     { return new E_fieldAcc(e, new PQ_name(loc, str("__real__"))); }
  -> "__imag__" e:PrimaryExpression
     { return new E_fieldAcc(e, new PQ_name(loc, str("__imag__"))); }
}


// ----------- gcc __attribute__ -----------
// This nonterminal gives me a good place to solve the ambiguity
// between associating the attrs with the label and associating
// them with the next declaration.
nonterm(StringRef) LabelAndColon {
  // Do not reduce this nonterminal with unconsumed attributes.
  forbid_next("__attribute__");
}


nonterm(Statement*) Statement {
  // Attribute applied to a label.
  //
  // Here, I do not use 'LabelAndColon' because that is prevented from
  // reducing when an "__attribute__" token is next.
  -> n:Identifier ":" asl:AttributeSpecifierList s:Statement
       { S_label *lbl = new S_label(loc, n, s);
         lbl->appendASL(asl);
         return lbl; }
}


impl_verbatim {
  // Prepend 'asl' onto 'typeSpecifier' and return the latter.
  template <class T>
  T *tsPrependElaboratedASL(AttributeSpecifierList *asl, T *typeSpecifier)
  {
    typeSpecifier->prependElaboratedASL(asl);
    return typeSpecifier;
  }
}

// Attributes after "class", "struct", "union", or "enum".
nonterm(TypeSpecifier*) ElaboratedTypeSpecifier {
  -> k:ClassKey asl:AttributeSpecifierList n:PQTypeName
       { return tsPrependElaboratedASL(asl,
           new TS_elaborated(loc, k, n)); }

  -> "enum" asl:AttributeSpecifierList n:PQTypeName
       { return tsPrependElaboratedASL(asl,
           new TS_elaborated(loc, TI_ENUM, n)); }
}

nonterm(TS_classSpec*) ClassSpecifier {
  -> k:ClassKey asl:AttributeSpecifierList n:ClassHeadNameOpt
                  b:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}"
       { popClassName();
         return tsPrependElaboratedASL(asl,
           new TS_classSpec(loc, k, n, b, memb)); }
}

nonterm(TS_enumSpec*) EnumSpecifier {
  -> "enum" asl:AttributeSpecifierList "{" list:EnumeratorListOpt "}"
       { return tsPrependElaboratedASL(asl,
           new TS_enumSpec(loc, NULL /*name*/, list)); }

  // Adding this adds one S/R conflict... it was 3 until I changed
  // Identifier to PQTypeName.  I think cc.gr should similarly use
  // PQName instead of Identifier, and catch qualifiers in tcheck...
  -> "enum" asl:AttributeSpecifierList n:PQTypeName "{" list:EnumeratorListOpt "}"
       { return tsPrependElaboratedASL(asl,
           new TS_enumSpec(loc, n->getName(), list)); }
}


impl_verbatim {
  // Create a definition of one of the 'make_TS_XXX_Declaration' and
  // 'make_TS_XXX_alone' functions.
  //
  // Each one combines a discriminator with up to two UberModifiers
  // (carrying cv-flags only) and two UMAASLs (with attributes and
  // cv-flags).  The UMAASLs have their ref counts decremented.
  //
  // The "discriminator" is the semantic value associated with the
  // grammar symbol that determined which rule to use of the various
  // choices for TypeSpecifier.
  //
  // Aside: A large macro like this can be conveniently formatted with:
  // https://github.com/smcpeak/scripts/blob/master/format-macro.py
  //
  #define define_make_TS_XXX_alone_and_Declaration(                            \
    TSClassName,               /* Name of the TypeSpecifier class. */          \
    functionName,              /* Base name of the functions to make. */       \
    DiscriminatorType,         /* Type of the discriminator. */                \
    discriminatorName,         /* Value of the discriminator. */               \
    fifthUberModifiers,        /* Possible extra UberModifiers. */             \
    tsObjectExpression)        /* Expression to create the TypeSpecifier. */   \
                                                                               \
    /* Shared core of the '_Declaration' and '_alone' functions.  This         \
     * returns a TypeSpecifier and stores into 'df' the DeclFlags              \
     * extracted from the union of the UberModifiers. */                       \
    static TSClassName *functionName##_core(                                   \
      DeclFlags /*OUT*/ &df,                                                   \
      CCParseShareable &env,                                                   \
      SourceLoc loc,                                                           \
      DiscriminatorType discriminatorName, /* Used by 'tsObjectExpression'. */ \
      UberModifiers m1,                                                        \
      UberModifiers m2,                                                        \
      UberModifiersAndASL * /*nullable dec*/ uma1,                             \
      UberModifiersAndASL * /*nullable dec*/ uma2)                             \
    {                                                                          \
      /* Combine all five potential sources of UberModifiers. */               \
      UberModifiers m = env.uberCombine(loc,                                   \
        fifthUberModifiers,                                                    \
        m1, m2,                                                                \
        umaaslUM(uma1), umaaslUM(uma2));                                       \
                                                                               \
      /* Pull out the declaration flags and return them in 'df'. */            \
      df = uberDeclFlags(m);                                                   \
                                                                               \
      /* Pull out the cv-flags, which 'tsObjectExpression' will use. */        \
      CVFlags cv = uberCVFlags(m);                                             \
                                                                               \
      /* Build the TypeSpecifier object to return. */                          \
      TSClassName *typeSpecifier = tsObjectExpression;                         \
                                                                               \
      /* Add the attributes.  There's always at least one if we have           \
       * reached this part of the code, since this function is called          \
       * from productions that have at least one. */                           \
      typeSpecifier->appendASL(umaaslASL(uma1));                               \
      typeSpecifier->appendASL(umaaslASL(uma2));                               \
                                                                               \
      /* These functions consume one level of ownership for the                \
       * UMAASL objects. */                                                    \
      decRefCount(uma1);                                                       \
      decRefCount(uma2);                                                       \
                                                                               \
      return typeSpecifier;                                                    \
    }                                                                          \
                                                                               \
    /* Create just the TypeSpecifier. */                                       \
    static TSClassName *functionName##_alone(                                  \
      CCParseShareable &env,                                                   \
      SourceLoc loc,                                                           \
      DiscriminatorType discriminatorName,                                     \
      UberModifiers m1,                                                        \
      UberModifiers m2,                                                        \
      UberModifiersAndASL * /*nullable dec*/ uma1,                             \
      UberModifiersAndASL * /*nullable dec*/ uma2)                             \
    {                                                                          \
      DeclFlags df = DF_NONE;          /* Value not used. */                   \
      TSClassName *ts =                                                        \
        functionName##_core(df /*OUT*/, env, loc, discriminatorName,           \
                            m1, m2, uma1, uma2);                               \
                                                                               \
      /* The grammar should preclude declaration modifiers here. */            \
      xassert(df == DF_NONE);                                                  \
                                                                               \
      return ts;                                                               \
    }                                                                          \
                                                                               \
    /* Wrap the TypeSpecifier in a Declaration. */                             \
    static Declaration *functionName##_Declaration(                            \
      CCParseShareable &env,                                                   \
      SourceLoc loc,                                                           \
      DiscriminatorType discriminatorName,                                     \
      UberModifiers m1,                                                        \
      UberModifiers m2,                                                        \
      UberModifiersAndASL * /*nullable dec*/ uma1,                             \
      UberModifiersAndASL * /*nullable dec*/ uma2)                             \
    {                                                                          \
      DeclFlags df = DF_NONE;          /* Value not used. */                   \
      TSClassName *ts =                                                        \
        functionName##_core(df /*OUT*/, env, loc, discriminatorName,           \
                            m1, m2, uma1, uma2);                               \
                                                                               \
      /* Wrap the TypeSpecifier in a Declaration. */                           \
      return new Declaration(df, ts, NULL /*decllist*/);                       \
    }

  // Build a TS_name.
  //
  // Defines make_TS_name_alone and make_TS_name_Declaration.
  define_make_TS_XXX_alone_and_Declaration(
    TS_name, make_TS_name,
    PQName *, name,
    UM_NONE,
    env.new_TS_name(loc, cv, name, false /*typename*/)
  );

  // Build a TS_simple.
  //
  // Defines make_TS_simple_alone and make_TS_simple_Declaration.
  define_make_TS_XXX_alone_and_Declaration(
    TS_simple, make_TS_simple,
    UberModifiers, k1,
    k1,
    env.new_TS_simple(loc, cv, env.uberSimpleType(loc, m))
  );

  // Augment a TypeSpecifier that is TS_elaborated, TS_classSpec, or
  // TS_enumSpec.
  //
  // Defines make_TS_elaborated_etc_alone and
  // make_TS_elaborated_etc_Declaration.
  define_make_TS_XXX_alone_and_Declaration(
    TypeSpecifier, make_TS_elaborated_etc,
    TypeSpecifier *, e,                // Existing TypeSpecifier.
    UM_NONE,

    // Destructively update 'e', then use it as the TypeSpecifier.
    (e->cv |= cv, e)
  );

  // Build a TS_typeof.
  //
  // Defines make_TS_typeof_alone and make_TS_typeof_Declaration.
  define_make_TS_XXX_alone_and_Declaration(
    TS_typeof, make_TS_typeof,
    ASTTypeof *, te,
    UM_NONE,
    new_TS_typeof(loc, cv, te)
  );
}


// Attributes as part of a declaration specifier.
//
// Aside from the first rule, the pattern is to replicate the existing
// productions in cc.gr except with AttributeSpecifier appearing at some
// point, which acts as a secondary discriminator (the primary being
// identifier versus type versus elaborated versus typeof), forcing us
// to use the rule here instead of there.
//
// Above each set of rules here is the cc.gr rule they are derived from,
// with "(*)" denoting the spot where the rule here insists on finding
// an attribute.  Each "(*)" generates one rule in this file, and they
// are in the left-to-right order of those markers.
//
// The nonterminal that goes into the "(*)" slot is one that must begin
// with '__attribute__', then contain a possibly empty sequence of
// AttributeSpecifiers and whatever UberModifiers were allowed to the
// *left* of the "(*)" marker in the original rule, such that when it is
// finished consuming available input, what remains is the primary
// discriminator used to select among the rules.
//
// After seeing an attribute, the rules here follow it with
// U[TA]MAASLOpt to collect whatever modifiers and additional attributes
// follow the first attribute.
//
nonterm(Declaration*) DeclSpecifier {
  // The case of a declaration specifier beginning with an attribute can
  // be handled uniformly with one new rule.
  //
  // At first, this looks ambiguous because we could parse a list of two
  // or more attributes in multiple ways.  But AttributeSpecifierList
  // has a 'forbid_next' that ensures that all available attributes will
  // be consumed as a single list rather than triggering this rule
  // multiple times.  (And while it would seem like we could just change
  // the rule to use 'AttributeSpecifier' instead of the list, that
  // causes a shift/reduce conflict with another rule that begins with a
  // list, and I would like to avoid that.)
  -> asl:AttributeSpecifierList d:DeclSpecifier
       { d->spec->prependASL(asl); return d; }

  // ---- PQTypeName ----

  // cc.gr has: n:PQTypeName m2:UberModifierSeqOpt (*)
  -> n:PQTypeName m2:UberModifierSeqOpt uma:AttributeSpecifier_UMAASLOpt
       { return make_TS_name_Declaration(*this, loc, n, UM_NONE, m2, uma, NULL_UMA); }

  // cc.gr has: m1:UberModifierSeq (*) n:PQTypeName m2:UberModifierSeqOpt (*)
  -> m1:UberModifierSeq uma1:AttributeSpecifier_UMAASLOpt n:PQTypeName uma2:UMAASLOpt
       { return make_TS_name_Declaration(*this, loc, n, m1, UM_NONE, uma1, uma2); }
  -> m1:UberModifierSeq n:PQTypeName m2:UberModifierSeqOpt uma:AttributeSpecifier_UMAASLOpt
       { return make_TS_name_Declaration(*this, loc, n, m1, m2, uma, NULL_UMA); }

  // ---- UberTypeKeyword ----

  // cc.gr has: k1:UberTypeKeyword m2:UberTypeAndModifierSeqOpt (*)
  -> k1:UberTypeKeyword m2:UberTypeAndModifierSeqOpt uma:AttributeSpecifier_UTAMAASLOpt
       { return make_TS_simple_Declaration(*this, loc, k1, UM_NONE, m2, uma, NULL_UMA); }

  // cc.gr has: m1:UberModifierSeq (*) k1:UberTypeKeyword m2:UberTypeAndModifierSeqOpt (*)
  -> m1:UberModifierSeq uma1:AttributeSpecifier_UMAASLOpt k1:UberTypeKeyword uma2:UTAMAASLOpt
       { return make_TS_simple_Declaration(*this, loc, k1, m1, UM_NONE, uma1, uma2); }
  -> m1:UberModifierSeq k1:UberTypeKeyword m2:UberTypeAndModifierSeqOpt uma:AttributeSpecifier_UTAMAASLOpt
       { return make_TS_simple_Declaration(*this, loc, k1, m1, m2, uma, NULL_UMA); }

  // ---- ElaboratedOrSpecifier ----

  // cc.gr has: e:ElaboratedOrSpecifier m2:UberModifierSeqOpt (*)
  -> e:ElaboratedOrSpecifier m2:UberModifierSeqOpt uma:AttributeSpecifier_UMAASLOpt
       { return make_TS_elaborated_etc_Declaration(*this, loc, e, UM_NONE, m2, uma, NULL_UMA); }

  // cc.gr has: m1:UberModifierSeq (*) e:ElaboratedOrSpecifier m2:UberModifierSeqOpt (*)
  -> m1:UberModifierSeq uma1:AttributeSpecifier_UMAASLOpt e:ElaboratedOrSpecifier uma2:UMAASLOpt
       { return make_TS_elaborated_etc_Declaration(*this, loc, e, m1, UM_NONE, uma1, uma2); }
  -> m1:UberModifierSeq e:ElaboratedOrSpecifier m2:UberModifierSeqOpt uma:AttributeSpecifier_UMAASLOpt
       { return make_TS_elaborated_etc_Declaration(*this, loc, e, m1, m2, uma, NULL_UMA); }

  // ---- TypeofTypeSpecifier ----

  // This section augments rules from earlier in this same file.  I
  // choose to follow the same pattern of augmentation, rather than just
  // fold the attribute possibilities into the rules above, because
  // UMAASL is a less efficient representation than UberModifiers, so I
  // only want to use it when there is actually an attribute present.

  // gnu.gr has: te:TypeofTypeSpecifier m2:UberModifierSeqOpt (*)
  -> te:TypeofTypeSpecifier m2:UberModifierSeqOpt uma:AttributeSpecifier_UMAASLOpt
       { return make_TS_typeof_Declaration(*this, loc, te, UM_NONE, m2, uma, NULL_UMA); }

  // gnu.gr has: m1:UberModifierSeq (*) te:TypeofTypeSpecifier m2:UberModifierSeqOpt (*)
  -> m1:UberModifierSeq uma1:AttributeSpecifier_UMAASLOpt te:TypeofTypeSpecifier uma2:UMAASLOpt
       { return make_TS_typeof_Declaration(*this, loc, te, m1, UM_NONE, uma1, uma2); }
  -> m1:UberModifierSeq te:TypeofTypeSpecifier m2:UberModifierSeqOpt uma:AttributeSpecifier_UMAASLOpt
       { return make_TS_typeof_Declaration(*this, loc, te, m1, m2, uma, NULL_UMA); }
}


// An AttributeSpecifier followed by UMAASLOpt.
nonterm(UberModifiersAndASL*) AttributeSpecifier_UMAASLOpt {
  // TODO: Elkhound feature to repeat this dup/del for all nonterminals
  // with this type?
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> as:AttributeSpecifier uma:UMAASLOpt
       { return umaaslPrependAS(as, uma); }
}

// Possibly empty sequence of UberModifiers and AttributeSpecifiers.
nonterm(UberModifiersAndASL*) UMAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> empty
       { return NULL; }
  -> uma:UMAASLOpt m:UberModifier
       { return umaaslCombineUM(*this, loc, uma, m); }
  -> uma:UMAASLOpt as:AttributeSpecifier
       { return umaaslAppendAS(uma, as); }
}

// An AttributeSpecifier followed by UTAMAASLOpt.
nonterm(UberModifiersAndASL*) AttributeSpecifier_UTAMAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> as:AttributeSpecifier uma:UTAMAASLOpt
       { return umaaslPrependAS(as, uma); }
}

// Possibly empty sequence of UberTypeAndModifiers and AttributeSpecifiers.
nonterm(UberModifiersAndASL*) UTAMAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> empty
       { return NULL; }
  -> uma:UTAMAASLOpt m:UberModifier
       { return umaaslCombineUM(*this, loc, uma, m); }
  -> uma:UTAMAASLOpt k:UberTypeKeyword
       { return umaaslCombineUM(*this, loc, uma, k); }
  -> uma:UTAMAASLOpt as:AttributeSpecifier
       { return umaaslAppendAS(uma, as); }
}


// This set of rules augments TypeSpecifier with attributes in the same
// way as DeclSpecifier.
//
// The main reason this is necessary is illustrated in the ambiguity in
// test/pprint/gnu-attr-on-conversion-id.cc, where the attributes
// associated with a TypeSpecifier can be confused with those associated
// with a Declarator.
//
// TODO: The duplication between DeclSpecifier and TypeSpecifier is
// really not good.  I should try to combine them in cc.gr, then here.
// However, that idea is blocked on the problem that TypeSpecifier uses
// multi-yield while DeclSpecifier does not (and I don't want to just
// give up on the latter).
//
nonterm(TypeSpecifier*) TypeSpecifier {
  // Do not reduce a TypeSpecifier until we have consumed all available
  // attributes.  This is also done for a few other related nonterminals
  // that consume attributes.
  forbid_next("__attribute__");

  // One rule handles a leading list of attributes.
  -> asl:AttributeSpecifierList ts:TypeSpecifier
       { ts->prependASL(asl); return ts; }

  // ---- TS_name ----

  // cc.gr has: n:PQTypeName cv2:UberCVQualifierSeqOpt (*)
  -> n:PQTypeName cv2:UberCVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt
       { return make_TS_name_alone(*this, loc, n, UM_NONE, cv2, uma, NULL_UMA); }

  // cc.gr has: cv1:UberCVQualifierSeq (*) n:PQTypeName cv2:UberCVQualifierSeqOpt (*)
  -> cv1:UberCVQualifierSeq uma1:AttributeSpecifier_UCVAASLOpt n:PQTypeName uma2:UCVAASLOpt
       { return make_TS_name_alone(*this, loc, n, cv1, UM_NONE, uma1, uma2); }
  -> cv1:UberCVQualifierSeq n:PQTypeName cv2:UberCVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt
       { return make_TS_name_alone(*this, loc, n, cv1, cv2, uma, NULL_UMA); }

  // ---- TS_simple ----

  // cc.gr has: k1:UberTypeKeyword m2:UberTypeAndCVQualifierSeqOpt (*)
  -> k1:UberTypeKeyword m2:UberTypeAndCVQualifierSeqOpt uma:AttributeSpecifier_UTACVAASLOpt
       { return make_TS_simple_alone(*this, loc, k1, UM_NONE, m2, uma, NULL_UMA); }

  // cc.gr has: m1:UberCVQualifierSeq (*) k1:UberTypeKeyword m2:UberTypeAndCVQualifierSeqOpt (*)
  -> m1:UberCVQualifierSeq uma1:AttributeSpecifier_UCVAASLOpt k1:UberTypeKeyword uma2:UTACVAASLOpt
       { return make_TS_simple_alone(*this, loc, k1, m1, UM_NONE, uma1, uma2); }
  -> m1:UberCVQualifierSeq k1:UberTypeKeyword m2:UberTypeAndCVQualifierSeqOpt uma:AttributeSpecifier_UTACVAASLOpt
       { return make_TS_simple_alone(*this, loc, k1, m1, m2, uma, NULL_UMA); }

  // ---- TS_elaborated, etc. ----

  // cc.gr has: e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt (*)
  -> e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt
       { return make_TS_elaborated_etc_alone(*this, loc, e, UM_NONE, m2, uma, NULL_UMA); }

  // cc.gr has: m1:UberCVQualifierSeq (*) e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt (*)
  -> m1:UberCVQualifierSeq uma1:AttributeSpecifier_UCVAASLOpt e:ElaboratedOrSpecifier uma2:UCVAASLOpt
       { return make_TS_elaborated_etc_alone(*this, loc, e, m1, UM_NONE, uma1, uma2); }
  -> m1:UberCVQualifierSeq e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt
       { return make_TS_elaborated_etc_alone(*this, loc, e, m1, m2, uma, NULL_UMA); }

  // ---- TS_typeof ----

  // gnu.gr has: te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt (*)
  -> te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt
       { return make_TS_typeof_alone(*this, loc, te, UM_NONE, cv2, uma, NULL_UMA); }

  // gnu.gr has: cv1:UberCVQualifierSeq (*) te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt (*)
  -> cv1:UberCVQualifierSeq uma1:AttributeSpecifier_UCVAASLOpt te:TypeofTypeSpecifier uma2:UCVAASLOpt
       { return make_TS_typeof_alone(*this, loc, te, cv1, UM_NONE, uma1, uma2); }
  -> cv1:UberCVQualifierSeq te:TypeofTypeSpecifier cv2:UberCVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt
       { return make_TS_typeof_alone(*this, loc, te, cv1, cv2, uma, NULL_UMA); }
}


// An AttributeSpecifier followed by UCVAASLOpt.
nonterm(UberModifiersAndASL*) AttributeSpecifier_UCVAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> as:AttributeSpecifier uma:UCVAASLOpt
       { return umaaslPrependAS(as, uma); }
}

// Possibly empty sequence of UberCVQualifiers and AttributeSpecifiers.
nonterm(UberModifiersAndASL*) UCVAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> empty
       { return NULL; }
  -> uma:UCVAASLOpt cv:UberCVQualifier
       { return umaaslCombineUM(*this, loc, uma, cv); }
  -> uma:UCVAASLOpt as:AttributeSpecifier
       { return umaaslAppendAS(uma, as); }
}

// An AttributeSpecifier followed by UTACVAASLOpt.
nonterm(UberModifiersAndASL*) AttributeSpecifier_UTACVAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  // See comments on TypeSpecifier.
  forbid_next("__attribute__");

  -> as:AttributeSpecifier uma:UTACVAASLOpt
       { return umaaslPrependAS(as, uma); }
}

// Possibly empty sequence of UberTypeAndCVQualifiers and AttributeSpecifiers.
nonterm(UberModifiersAndASL*) UTACVAASLOpt {
  fun dup(uma) { return incRefCount(uma); }
  fun del(uma) { decRefCount(uma); }

  -> empty
       { return NULL; }
  -> uma:UTACVAASLOpt cv:UberCVQualifier
       { return umaaslCombineUM(*this, loc, uma, cv); }
  -> uma:UTACVAASLOpt k:UberTypeKeyword
       { return umaaslCombineUM(*this, loc, uma, k); }
  -> uma:UTACVAASLOpt as:AttributeSpecifier
       { return umaaslAppendAS(uma, as); }
}


// Attribute after the "," in a sequence of declarators.
nonterm(FakeList<Declarator>*) InitDeclaratorList {
  -> d:InitDeclarator "," asl:AttributeSpecifierList decllist:InitDeclaratorList
       {
         Declarator *firstAfter = fl_first(decllist);

         // I can't just stick the attributes on 'firstAfter->decl'
         // because they'll mean something different there if it is
         // something like D_pointer that denotes a type constructor.
         // So, instead, synthesize a D_grouping.
         //
         // For maximum fidelity, I could allow attributes to be
         // associated with Declarator (rather than IDeclarator), but
         // that seems unnecessary, and greater proliferation of
         // attributes is undesirable.
         D_grouping *g = new D_grouping(loc, firstAfter->decl);
         g->prependASL(asl);

         // Insert 'g' where 'firstAfter->decl' was.
         firstAfter->decl = g;

         // Connect 'd' at the head of the list.
         d->setNext(firstAfter);
         return FakeList<Declarator>::makeList(d);
       }
}


impl_verbatim {
  // Make a D_pointer with flags and attributes from 'cv1' and 'uma',
  // and on top of 'base'.
  static D_pointer *make_D_pointer(
    SourceLoc loc,
    CVFlags cv1,
    UberModifiersAndASL * /*dec*/ uma,
    IDeclarator *base)
  {
    // Get the combined cv-flags.
    CVFlags cv = cv1 | uberCVFlags(umaaslUM(uma));

    // Build our desired D_pointer.
    D_pointer *ret = new D_pointer(loc, cv, base);
    ret->appendASL(umaaslASL(uma));

    // Consume 'uma'.
    decRefCount(uma);

    return ret;
  }

  // Make a D_grouping with 'list' on top of 'base'.
  static D_grouping *make_D_grouping(
    SourceLoc loc,
    AttributeSpecifierList *list,
    IDeclarator *base)
  {
    D_grouping *ret = new D_grouping(loc, base);
    ret->prependASL(list);
    return ret;
  }

}

nonterm(IDeclarator*) Declarator {
  // "*", then some cv, then *one* __attribute__, which causes the
  // parser to commit to this production, then cv+attr seq
  -> "*" cv:CVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt d:Declarator
       { return make_D_pointer(loc, cv, uma, d); }

  // perhaps attributes should be allowed after "&" and "C::*"?

  // this is slightly more tolerant than gcc is, since it allows
  // attributes just inside the ")" of a D_grouping, whereas gcc
  // doesn't
  -> d:DirectDeclarator list:AttributeSpecifierList
       { d->appendASL(list); return d; }
}


nonterm(IDeclarator*) DirectDeclarator {
  -> "(" list:AttributeSpecifierList d:Declarator ")"
       { return make_D_grouping(loc, list, d); }
}


nonterm(IDeclarator*) AbstractDeclarator {
  -> "*" cv:CVQualifierSeqOpt uma:AttributeSpecifier_UCVAASLOpt d:AbstractDeclaratorOpt
       { return make_D_pointer(loc, cv, uma, d); }

  -> d:DirectAbstractDeclarator list:AttributeSpecifierList
       { d->appendASL(list); return d; }
}

nonterm(IDeclarator*) DirectAbstractDeclarator {
  -> "(" list:AttributeSpecifierList d:AbstractDeclarator ")"
       { return make_D_grouping(loc, list, d); }
}


// Attributes after bitfields, for example in Linux:
// UCHAR8 SampleResolution:2 __attribute__ ((packed));
nonterm(Declarator*) MemberDeclarator {
  -> n:IdentifierOpt ":" e:ConstantExpression list:AttributeSpecifierList
       {
         PQName *name = n? new PQ_name(loc, n) : NULL;
         D_bitfield *bf = new D_bitfield(loc, name, e);
         bf->appendASL(list);
         return new Declarator(bf, NULL /*init*/);
       }
}


// -- attributes themselves --
// http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Attribute-Syntax.html

// "A word (which may be an identifier such as unused, or a reserved
// word such as const)."
nonterm(StringRef) AttributeWord {
  // non-keyword name
  -> n:TOK_NAME         { return n; }

  // keywords
  -> "asm"              { return str("asm"); }
  -> "auto"             { return str("auto"); }
  -> "break"            { return str("break"); }
  -> "bool"             { return str("bool"); }
  -> "case"             { return str("case"); }
  -> "catch"            { return str("catch"); }
  -> "cdecl"            { return str("cdecl"); }
  -> "char"             { return str("char"); }
  -> "class"            { return str("class"); }
  -> "const"            { return str("const"); }
  -> "const_cast"       { return str("const_cast"); }
  -> "continue"         { return str("continue"); }
  -> "default"          { return str("default"); }
  -> "delete"           { return str("delete"); }
  -> "do"               { return str("do"); }
  -> "double"           { return str("double"); }
  -> "dynamic_cast"     { return str("dynamic_cast"); }
  -> "else"             { return str("else"); }
  -> "enum"             { return str("enum"); }
  -> "explicit"         { return str("explicit"); }
  -> "export"           { return str("export"); }
  -> "extern"           { return str("extern"); }
  -> "false"            { return str("false"); }
  -> "float"            { return str("float"); }
  -> "for"              { return str("for"); }
  -> "friend"           { return str("friend"); }
  -> "goto"             { return str("goto"); }
  -> "if"               { return str("if"); }
  -> "inline"           { return str("inline"); }
  -> "int"              { return str("int"); }
  -> "long"             { return str("long"); }
  -> "mutable"          { return str("mutable"); }
  -> "namespace"        { return str("namespace"); }
  -> "new"              { return str("new"); }
  -> "operator"         { return str("operator"); }
  -> "pascal"           { return str("pascal"); }
  -> "private"          { return str("private"); }
  -> "protected"        { return str("protected"); }
  -> "public"           { return str("public"); }
  -> "register"         { return str("register"); }
  -> "reinterpret_cast" { return str("reinterpret_cast"); }
  -> "return"           { return str("return"); }
  -> "short"            { return str("short"); }
  -> "signed"           { return str("signed"); }
  -> "sizeof"           { return str("sizeof"); }
  -> "static"           { return str("static"); }
  -> "static_cast"      { return str("static_cast"); }
  -> "struct"           { return str("struct"); }
  -> "switch"           { return str("switch"); }
  -> "template"         { return str("template"); }
  -> "this"             { return str("this"); }
  -> "throw"            { return str("throw"); }
  -> "true"             { return str("true"); }
  -> "try"              { return str("try"); }
  -> "typedef"          { return str("typedef"); }
  -> "typeid"           { return str("typeid"); }
  -> "typename"         { return str("typename"); }
  -> "union"            { return str("union"); }
  -> "unsigned"         { return str("unsigned"); }
  -> "using"            { return str("using"); }
  -> "virtual"          { return str("virtual"); }
  -> "void"             { return str("void"); }
  -> "volatile"         { return str("volatile"); }
  -> "wchar_t"          { return str("wchar_t"); }
  -> "while"            { return str("while"); }

  // don't know if I need to allow these; gcc 2.95.3 doesn't like them
  //  // GNU extensions
  //  TOK___ATTRIBUTE__,       "__attribute__",             :    n
  //  TOK___FUNCTION__,        "__FUNCTION__",              :    n
  //  TOK___LABEL__,           "__label__",                 :    n
  //  TOK___PRETTY_FUNCTION__, "__PRETTY_FUNCTION__",       :    n
  //  TOK___TYPEOF__,          "__typeof__",                :    n
}

nonterm(FakeList<ArgExpression>*) CommaSepExpressionListOpt {
  -> empty                 { return FakeList<ArgExpression>::emptyList(); }
  -> el:ExpressionList     { return el; }
}

nonterm(FakeList<ArgExpression>*) AttributeParameters {
//    -> id:Identifier "," exprs:CommaSepExpressionListOpt ;
  // NOTE: the below includes the above, except that the first
  // expression, if an identifier, should not be typechecked as an
  // E_variable, since it need not match a declared name; first it
  // should be checked against known attribute parameters (maybe?).
  -> exprs:CommaSepExpressionListOpt    { return exprs; }
}

nonterm(Attribute*) Attribute {
  -> empty
     { return new AT_empty(loc); }

  -> w:AttributeWord
     { return new AT_word(loc, w); }

  -> w:AttributeWord "(" ap:AttributeParameters ")"
     { return new AT_func(loc, w, ap); }
}

nonterm(AttributeSpecifier*) AttributeList {
  -> at:Attribute
     { return new AttributeSpecifier(at, NULL /*next*/); }

  -> at:Attribute "," ap:AttributeList
     { return new AttributeSpecifier(at, ap); }
}

nonterm(AttributeSpecifier*) AttributeSpecifier {
  -> "__attribute__" "(" "(" ap:AttributeList ")" ")"
     { return ap; }
}

nonterm(AttributeSpecifierList*) AttributeSpecifierList {
  // Ensure that each use of ASL will consume all attributes at once,
  // rather than possibly leaving some to be consumed through multiple
  // uses of ASL.
  forbid_next("__attribute__");

  -> as:AttributeSpecifier
     { return new AttributeSpecifierList(as, NULL /*next*/); }

  -> as:AttributeSpecifier asl:AttributeSpecifierList
     { return new AttributeSpecifierList(as, asl); }
}


// quarl 2006-06-14
//    'using namespace N __attribute__(__strong__)'
//    see in/gnu/k0009.cc or
//    /usr/include/c++/3.4/i486-linux-gnu/bits/c++config.h

nonterm(NamespaceDecl*) NamespaceDecl {
  -> "using" "namespace" n:IdExpression AttributeSpecifierList ";"
       { xunimp(stringc << loc << " using namespace __attribute__"
                " (a86c8a1e-2cd7-41bd-8a23-f9049358c166)");
         return new ND_usingDir(n); }
}


// EOF
